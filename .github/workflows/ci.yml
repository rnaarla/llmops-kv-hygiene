# =============================================================================
# KV-Hygiene CI/CD Pipeline - Rebuilt from Scratch
# =============================================================================
# Clean, robust pipeline with fixed coverage collection and clear job flow
# =============================================================================

name: kv-hygiene-ci

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  COVERAGE_THRESHOLD: '90'
  PYTHON_VERSION: '3.11'
  TEST_SELECTION_ENABLED: 'true'
  TEST_SELECTION_THRESHOLD: '20'

permissions:
  contents: write
  packages: write
  security-events: write
  id-token: write
  pull-requests: write

jobs:
  # ===========================================================================
  # PHASE 0: Dynamic Configuration
  # ===========================================================================
  generate-matrix:
    name: Generate Test Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
      changed_files: ${{ steps.changes.outputs.files }}
      test_selection_mode: ${{ steps.changes.outputs.mode }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for accurate diff analysis

      # === CONTEXT-AWARE TEST SELECTION ===
      - name: Detect changed files
        id: changes
        run: |
          python - <<'PY'
          import json, os, subprocess, sys

          # Get changed files compared to base branch
          base = os.environ.get('GITHUB_BASE_REF', 'main')
          if os.environ.get('GITHUB_EVENT_NAME') == 'pull_request':
              cmd = f'git diff --name-only origin/{base}...HEAD'
          else:
              cmd = 'git diff --name-only HEAD~1 HEAD'

          result = subprocess.run(cmd.split(), capture_output=True, text=True)
          changed = [f.strip() for f in result.stdout.split('\n') if f.strip()]

          print(f"Changed files: {changed}")

          # Determine test selection mode
          threshold = int(os.environ.get('TEST_SELECTION_THRESHOLD', '20'))
          enabled = os.environ.get('TEST_SELECTION_ENABLED', 'true').lower() == 'true'

          mode = 'full'
          if enabled and len(changed) < threshold:
              # Check if dependency-critical files changed
              critical_patterns = ['.github/', 'requirements.txt', 'setup.py', 'pyproject.toml']
              has_critical = any(any(p in f for p in critical_patterns) for f in changed)
              mode = 'full' if has_critical else 'selective'

          serialized = json.dumps(changed)
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              print(f"files={serialized}", file=f)
              print(f"mode={mode}", file=f)

          print(f"Test selection mode: {mode}")
          PY

      - name: Generate matrix from config
        id: mk
        run: |
          python3 - <<'PY'
          import json, os, sys
          try:
              path = 'ci_cd/test_matrix.json'
              with open(path, 'r', encoding='utf-8') as f:
                  cfg = json.load(f)
              matrix = {
                'os': cfg.get('platform', ['ubuntu-latest']),
                'python-version': cfg.get('python', ['3.11'])
              }
              print('Matrix:', matrix)
              with open(os.environ['GITHUB_OUTPUT'], 'a') as output:
                  output.write(f"matrix={json.dumps(matrix)}\n")
          except json.JSONDecodeError as e:
              print(f"ERROR: Invalid JSON in {path}: {e}", file=sys.stderr)
              sys.exit(1)
          except Exception as e:
              print(f"ERROR: Failed to load matrix: {e}", file=sys.stderr)
              sys.exit(1)
          PY

  # ===========================================================================
  # PHASE 1: Code Quality
  # ===========================================================================
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Ruff
        run: ruff check .

      - name: Run Black
        run: black --check .

      - name: Run Mypy
        run: mypy tools tests

  policy-guard:
    name: Policy Validation
    needs: lint
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Install Conftest
        run: |
          set -euo pipefail
          VERSION="0.45.0"
          curl -sSL -o conftest.tar.gz "https://github.com/open-policy-agent/conftest/releases/download/v${VERSION}/conftest_${VERSION}_Linux_x86_64.tar.gz"
          tar -xzf conftest.tar.gz
          sudo mv conftest /usr/local/bin/conftest
          conftest --version

      - name: Evaluate policies
        run: conftest test .github/workflows/ci.yml -p policy

  # ===========================================================================
  # PHASE 2: Testing with Coverage
  # ===========================================================================
  test:
    name: Test (${{ matrix.os }}, Python ${{ matrix.python-version }})
    needs: [policy-guard, generate-matrix]
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests with coverage
        run: |
          mkdir -p coverage-reports
          pytest -v \
            --cov=tools \
            --cov-report=xml:coverage-reports/coverage.xml \
            --cov-report=json:coverage-reports/coverage.json \
            --cov-report=term

      - name: Verify coverage file exists
        run: |
          if [ ! -f coverage-reports/coverage.json ]; then
            echo "ERROR: coverage.json was not created!"
            exit 1
          fi
          echo "âœ… Coverage file created successfully"
          ls -lh coverage-reports/

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-${{ matrix.os }}-py${{ matrix.python-version }}
          path: coverage-reports/coverage.json
          retention-days: 7

  # ===========================================================================
  # PHASE 3: Coverage Aggregation & Quality Gate
  # ===========================================================================
  coverage:
    name: Aggregate Coverage & Quality Gate
    needs: test
    runs-on: ubuntu-latest
    outputs:
      coverage_pct: ${{ steps.aggregate.outputs.coverage }}

    steps:
      - uses: actions/checkout@v4

      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-coverage
          pattern: coverage-*
          merge-multiple: false

      - name: Debug - Show downloaded artifacts
        run: |
          echo "=== Downloaded artifacts structure ==="
          find all-coverage -type f -name "*.json" | sort
          echo ""
          echo "=== Artifact sizes ==="
          find all-coverage -type f -name "*.json" -exec ls -lh {} \;

      - name: Aggregate coverage
        id: aggregate
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os
          from pathlib import Path

          coverage_dir = Path("all-coverage")
          coverage_files = list(coverage_dir.rglob("coverage.json"))

          print(f"Found {len(coverage_files)} coverage files")

          if not coverage_files:
              print("ERROR: No coverage files found!")
              print("Directory structure:")
              for item in coverage_dir.rglob("*"):
                  print(f"  {item}")
              sys.exit(1)

          total_statements = 0
          total_covered = 0

          for file in coverage_files:
              print(f"\nProcessing: {file}")
              try:
                  data = json.loads(file.read_text())
                  totals = data.get("totals", {})
                  statements = totals.get("num_statements", 0)
                  covered = totals.get("covered_lines", 0)

                  print(f"  Statements: {statements}")
                  print(f"  Covered: {covered}")
                  print(f"  Coverage: {(covered/statements*100):.2f}%" if statements > 0 else "  Coverage: 0%")

                  total_statements += statements
                  total_covered += covered
              except Exception as e:
                  print(f"  ERROR reading file: {e}")
                  continue

          if total_statements == 0:
              print("\nERROR: No statements found in any coverage file!")
              sys.exit(1)

          coverage_pct = (total_covered / total_statements) * 100

          print(f"\n{'='*60}")
          print(f"TOTAL COVERAGE: {coverage_pct:.2f}%")
          print(f"Total Statements: {total_statements}")
          print(f"Total Covered: {total_covered}")
          print(f"{'='*60}")

          # Write to GitHub output
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"coverage={coverage_pct:.2f}\n")

          # Save aggregate report
          aggregate_data = {
              "coverage_pct": coverage_pct,
              "total_statements": total_statements,
              "total_covered": total_covered,
              "file_count": len(coverage_files)
          }

          Path("aggregate-coverage.json").write_text(json.dumps(aggregate_data, indent=2))

          print(f"\nâœ… Aggregate coverage: {coverage_pct:.2f}%")
          EOF

      - name: Quality gate - Coverage threshold
        run: |
          COVERAGE="${{ steps.aggregate.outputs.coverage }}"
          THRESHOLD="${{ env.COVERAGE_THRESHOLD }}"

          echo "Coverage: ${COVERAGE}%"
          echo "Threshold: ${THRESHOLD}%"

          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "âŒ Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
            exit 1
          else
            echo "âœ… Coverage ${COVERAGE}% meets threshold ${THRESHOLD}%"
          fi

      - name: Upload aggregate coverage
        uses: actions/upload-artifact@v4
        with:
          name: aggregate-coverage
          path: aggregate-coverage.json

  # ===========================================================================
  # PHASE 4: Security Scanning
  # ===========================================================================
  security-scan:
    name: Security Scan (Trivy)
    needs: lint
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@0.33.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ===========================================================================
  # PHASE 5: Docker Build & Scan (Main Branch Only)
  # ===========================================================================
  docker:
    name: Docker Build & Scan
    needs: [coverage, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.cpu
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@0.33.0
        with:
          image-ref: ghcr.io/${{ github.repository }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-image.sarif'

      - name: Upload image scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-image.sarif'

  # ===========================================================================
  # PHASE 6: Update Metrics
  # ===========================================================================
  update-metrics:
    name: Update Quality Metrics
    needs: [coverage, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download aggregate coverage
        uses: actions/download-artifact@v4
        with:
          name: aggregate-coverage

      - name: Update quality metrics
        run: |
          python3 << 'EOF'
          import json
          from pathlib import Path
          from datetime import datetime

          # Load aggregate coverage
          aggregate = json.loads(Path("aggregate-coverage.json").read_text())
          coverage_pct = aggregate["coverage_pct"]

          # Load or create metrics file
          metrics_file = Path("ci_metrics/quality_metrics.json")
          metrics_file.parent.mkdir(exist_ok=True)

          if metrics_file.exists():
              metrics = json.loads(metrics_file.read_text())
          else:
              metrics = {
                  "coverage": {"baseline": 90.0, "current": 0.0},
                  "vulnerabilities": {"high": 0, "critical": 0},
                  "sbom": {"baseline_hash": "", "current_hash": ""},
                  "history": []
              }

          # Update current coverage
          metrics["coverage"]["current"] = coverage_pct

          # Update baseline (moving average of last 5 successful runs)
          metrics["history"].append({
              "timestamp": datetime.utcnow().isoformat(),
              "coverage": coverage_pct,
              "run_id": "${{ github.run_id }}"
          })

          # Keep only last 10 history entries
          metrics["history"] = metrics["history"][-10:]

          # Calculate new baseline from successful runs
          successful_runs = [h for h in metrics["history"] if h["coverage"] > 0]
          if len(successful_runs) >= 3:
              recent_coverages = [h["coverage"] for h in successful_runs[-5:]]
              metrics["coverage"]["baseline"] = sum(recent_coverages) / len(recent_coverages)

          metrics["last_updated"] = datetime.utcnow().isoformat()

          # Write back
          metrics_file.write_text(json.dumps(metrics, indent=2))

          print(f"âœ… Updated metrics:")
          print(f"   Current coverage: {coverage_pct:.2f}%")
          print(f"   Baseline coverage: {metrics['coverage']['baseline']:.2f}%")
          EOF

      - name: Commit updated metrics
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ci_metrics/quality_metrics.json
          git diff --staged --quiet || git commit -m "ci: update quality metrics [skip ci]"
          git push

  # ===========================================================================
  # PHASE 7: Summary Report
  # ===========================================================================
  summary:
    name: CI Summary
    needs: [lint, test, coverage, security-scan]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Generate summary
        run: |
          echo "## ðŸŽ¯ CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Lint | ${{ needs.lint.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tests | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Coverage | ${{ needs.coverage.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Scan | ${{ needs.security-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.coverage.outputs.coverage_pct }}" != "" ]; then
            echo "### ðŸ“Š Coverage: ${{ needs.coverage.outputs.coverage_pct }}%" >> $GITHUB_STEP_SUMMARY
          fi
